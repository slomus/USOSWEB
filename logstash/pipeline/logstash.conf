input {
  file {
    path => "/app/logs/*.log"
    start_position => "end"
    sincedb_path => "/tmp/logstash_sincedb"
    codec => "plain"
    tags => ["usosweb"]
  }

  http {
    port => 8080
    tags => ["http_input"]
  }
}

filter {
  if [tags][0] == "usosweb" {
    grok {
      match => {
        "message" => "%{DATA:service_name} \| %{TIMESTAMP_ISO8601:timestamp} \| %{WORD:log_level} \| %{GREEDYDATA:log_message}"
      }
    }

    date {
      match => [ "timestamp", "yyyy-MM-dd HH:mm:ss.SSS" ]
      target => "@timestamp"
    }

    if [log_message] =~ /Incoming request/ {
      grok {
        match => {
          "log_message" => "Incoming request: %{WORD:http_method} %{URIPATH:http_path} from %{IP:client_ip}"
        }
        add_tag => ["http_request"]
      }
    }

    if [log_message] =~ /Request completed/ {
      grok {
        match => {
          "log_message" => "Request completed: %{WORD:http_method} %{URIPATH:http_path} -> %{NUMBER:http_status:int} in %{NUMBER:duration_ms:int}ms"
        }
        add_tag => ["http_response"]
      }
    }

    if [log_level] == "error" {
      mutate {
        add_tag => ["error", "alert"]
      }
    }

    mutate {
      add_field => { "environment" => "development" }
      add_field => { "project" => "usosweb" }
      add_field => { "processed_at" => "%{@timestamp}" }
    }
  }
}

output { #NOTE: we could store the data in a table or via web hooks, for now the data is stored in a standalone file
  file {
    path => "/app/processed-logs/usosweb-processed-%{+YYYY.MM.dd}.json"
    codec => json_lines
  }

  if [log_level] {
    redis {
      host => "redis"
      port => 6379
      data_type => "list"
      key => "processed_logs"
    }
  }

  if [log_level] == "error" {
    stdout {
      codec => rubydebug
    }
  }
}
